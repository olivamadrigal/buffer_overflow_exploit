# buffer_overflow_exploit
Buffer overflow exploit that spawns root shell

# CMPE 220 System Software
# Lab 2, Fall 2016
Samira C. Oliva Madrigal

All lab files and detailed instructions are provided by Professor Hungwen Li.
The task is to apply understanding of buffer overflow vulnerability, use of the stack, x86 assembly code embedding to: 1) exploit the vulnerability and obtain root privilege 2) then, enforce system provided protection schemes (e.g., ASLR) and test against the exploit with analysis on failure or success of the enabled security feature. Buffer overflow is extremely important, and despite secure coding standards in various languages (https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts), it is sometimes easy to overlook (e.g., TLS heartbleed bug) which is a buffer overflow exploit through which keys and sensitive information were obtained (https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2014-0160). Sometimes, not setting and checking for length of a buffer can be easy to overlook if the definition makes sense in the context of use. Specific instructions from lab provided instructions may be found below:


//tested on Fedora 32-bit linux with root access; reference fedora linux docs for CLI and values.

//ASLR : disable address space layout randomization :
$sysctl -w kernel.randomize_va_space=0

//STACK GUARD : disable code from exceuting on the stack
$sysctl -w kernel.exe-shield=0

//SHELL PRIVILEDGE DROPPING
//bin/bash may be implemented to automatically drop priviledges of a shell script when invoked
//therefore for our purposes, we use the zsh (may need to install in Fedora) then must link  this shell
//to sh :

$cd /bin
$rm sh
$ln -s /bin/zsh /bin/sh

//STACK GUARD FROM GCC :
//gcc has this option which you disable like so : 
$GCC -fno-stack-protector main.c

Shell code : = our exploit code in C language --> translated  to assembly ---> encoded in hex. 

See this : https://man7.org/linux/man-pages/man2/execve.2.html
for execve system call is used to execute a program. We are passing the starting address of buffer as the path to code, and again the address of buffer as our command line arguments for the program. 

//as root : compile exploit program to make it set-root-uid :
$ gcc -o stack -fno-stack-protector stack.c
$ chmod 4755 stack 

Goal : get normal user to run code and spawn a shell with root priviledges.
Buffer overflow is possible anywhere we input to a buffer without checking boundaries (why we always use strncpy and not strcpy...) 

Our contribution : the contents of badfile == spawns root shell.

Lab provides partial code for exploit : 

call_shellcode.c // example code : shows you how to launch shell code
stack.c // file with vulnerability (reads from bad file), must compile it & make it set-root-uid

$ gcc -o stack -fno-stack-protector stack.c
$ chmod 4755 stack 

your job is to writ the contents of badfile using exploit.c 
	then when user runs ./stack, the exploit will happen.

$su root
$gcc -o stack -fno-stack-protector stack.c
$chmodd 4755 stack
$exit

$gcc -o exploit exploit.c
$./exploit
$./stack

https://www.gnu.org/software/libc/manual/html_node/Backtraces.html

See report for video task description and video demos:
3 videos (should be viewable) for all 3 tasks as part of lab completion: 
https://youtu.be/IdWtYz6KoKU (task1)




